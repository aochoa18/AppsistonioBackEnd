import { isReflectMetadataSupported, isSubtypeOf, isValueDefined, logError, logWarning, MISSING_REFLECT_CONF_MSG, nameof, } from './helpers';
import { injectMetadataInformation } from './metadata';
import { extractOptionBase } from './options-base';
import { ArrayTypeDescriptor, ensureTypeDescriptor, MapTypeDescriptor, SetTypeDescriptor, } from './type-descriptor';
export function jsonMember(optionsOrPrototype, propKey) {
    if (propKey !== undefined
        && (typeof propKey === 'string' || typeof propKey === 'symbol')) {
        const prototype = optionsOrPrototype;
        const decoratorName = `@jsonMember on ${nameof(prototype.constructor)}.${String(propKey)}`;
        if (!isReflectMetadataSupported) {
            logError(`${decoratorName}: ReflectDecorators is required if no 'constructor' option is`
                + ` specified.`);
            return;
        }
        const reflectPropCtor = Reflect.getMetadata('design:type', prototype, propKey);
        if (reflectPropCtor == null) {
            logError(`${decoratorName}: could not resolve detected property constructor at runtime.${MISSING_REFLECT_CONF_MSG}`);
            return;
        }
        const typeDescriptor = ensureTypeDescriptor(reflectPropCtor);
        if (isSpecialPropertyType(decoratorName, typeDescriptor)) {
            return;
        }
        injectMetadataInformation(prototype, propKey, {
            type: typeDescriptor,
            key: propKey.toString(),
            name: propKey.toString(),
        });
    }
    else {
        return (target, _propKey) => {
            var _a, _b;
            const options = (_a = optionsOrPrototype) !== null && _a !== void 0 ? _a : {};
            let typeDescriptor;
            const decoratorName = `@jsonMember on ${nameof(target.constructor)}.${String(_propKey)}`;
            if (options.hasOwnProperty('constructor')) {
                if (!isValueDefined(options.constructor)) {
                    logError(`${decoratorName}: cannot resolve specified property constructor at`
                        + ' runtime.');
                    return;
                }
                typeDescriptor = ensureTypeDescriptor(options.constructor);
                if (isReflectMetadataSupported && !isSubtypeOf(typeDescriptor.ctor, Reflect.getMetadata('design:type', target, _propKey))) {
                    logWarning(`${decoratorName}: detected property type does not match`
                        + ` 'constructor' option.`);
                }
            }
            else if (isReflectMetadataSupported) {
                const reflectCtor = Reflect.getMetadata('design:type', target, _propKey);
                if (reflectCtor == null) {
                    logError(`${decoratorName}: cannot resolve detected property constructor at`
                        + ` runtime.`);
                    return;
                }
                typeDescriptor = ensureTypeDescriptor(reflectCtor);
            }
            else if (options.deserializer === undefined) {
                logError(`${decoratorName}: ReflectDecorators is required if no 'constructor' option`
                    + ` is specified.`);
                return;
            }
            if (typeDescriptor !== undefined
                && isSpecialPropertyType(decoratorName, typeDescriptor)) {
                return;
            }
            injectMetadataInformation(target, _propKey, {
                type: typeDescriptor,
                emitDefaultValue: options.emitDefaultValue,
                isRequired: options.isRequired,
                options: extractOptionBase(options),
                key: _propKey.toString(),
                name: (_b = options.name) !== null && _b !== void 0 ? _b : _propKey.toString(),
                deserializer: options.deserializer,
                serializer: options.serializer,
            });
        };
    }
}
function isSpecialPropertyType(decoratorName, typeDescriptor) {
    if (!(typeDescriptor instanceof ArrayTypeDescriptor) && typeDescriptor.ctor === Array) {
        logError(`${decoratorName}: property is an Array. Use the jsonArrayMember decorator to`
            + ` serialize this property.`);
        return true;
    }
    if (!(typeDescriptor instanceof SetTypeDescriptor) && typeDescriptor.ctor === Set) {
        logError(`${decoratorName}: property is a Set. Use the jsonSetMember decorator to`
            + ` serialize this property.`);
        return true;
    }
    if (!(typeDescriptor instanceof MapTypeDescriptor) && typeDescriptor.ctor === Map) {
        logError(`${decoratorName}: property is a Map. Use the jsonMapMember decorator to`
            + ` serialize this property.`);
        return true;
    }
    return false;
}
//# sourceMappingURL=json-member.js.map