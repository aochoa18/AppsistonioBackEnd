"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonMember = void 0;
var helpers_1 = require("./helpers");
var metadata_1 = require("./metadata");
var options_base_1 = require("./options-base");
var type_descriptor_1 = require("./type-descriptor");
function jsonMember(optionsOrPrototype, propKey) {
    if (propKey !== undefined
        && (typeof propKey === 'string' || typeof propKey === 'symbol')) {
        var prototype = optionsOrPrototype;
        var decoratorName = "@jsonMember on " + helpers_1.nameof(prototype.constructor) + "." + String(propKey);
        if (!helpers_1.isReflectMetadataSupported) {
            helpers_1.logError(decoratorName + ": ReflectDecorators is required if no 'constructor' option is"
                + " specified.");
            return;
        }
        var reflectPropCtor = Reflect.getMetadata('design:type', prototype, propKey);
        if (reflectPropCtor == null) {
            helpers_1.logError(decoratorName + ": could not resolve detected property constructor at runtime." + helpers_1.MISSING_REFLECT_CONF_MSG);
            return;
        }
        var typeDescriptor = type_descriptor_1.ensureTypeDescriptor(reflectPropCtor);
        if (isSpecialPropertyType(decoratorName, typeDescriptor)) {
            return;
        }
        metadata_1.injectMetadataInformation(prototype, propKey, {
            type: typeDescriptor,
            key: propKey.toString(),
            name: propKey.toString(),
        });
    }
    else {
        return function (target, _propKey) {
            var _a, _b;
            var options = (_a = optionsOrPrototype) !== null && _a !== void 0 ? _a : {};
            var typeDescriptor;
            var decoratorName = "@jsonMember on " + helpers_1.nameof(target.constructor) + "." + String(_propKey);
            if (options.hasOwnProperty('constructor')) {
                if (!helpers_1.isValueDefined(options.constructor)) {
                    helpers_1.logError(decoratorName + ": cannot resolve specified property constructor at"
                        + ' runtime.');
                    return;
                }
                typeDescriptor = type_descriptor_1.ensureTypeDescriptor(options.constructor);
                if (helpers_1.isReflectMetadataSupported && !helpers_1.isSubtypeOf(typeDescriptor.ctor, Reflect.getMetadata('design:type', target, _propKey))) {
                    helpers_1.logWarning(decoratorName + ": detected property type does not match"
                        + " 'constructor' option.");
                }
            }
            else if (helpers_1.isReflectMetadataSupported) {
                var reflectCtor = Reflect.getMetadata('design:type', target, _propKey);
                if (reflectCtor == null) {
                    helpers_1.logError(decoratorName + ": cannot resolve detected property constructor at"
                        + " runtime.");
                    return;
                }
                typeDescriptor = type_descriptor_1.ensureTypeDescriptor(reflectCtor);
            }
            else if (options.deserializer === undefined) {
                helpers_1.logError(decoratorName + ": ReflectDecorators is required if no 'constructor' option"
                    + " is specified.");
                return;
            }
            if (typeDescriptor !== undefined
                && isSpecialPropertyType(decoratorName, typeDescriptor)) {
                return;
            }
            metadata_1.injectMetadataInformation(target, _propKey, {
                type: typeDescriptor,
                emitDefaultValue: options.emitDefaultValue,
                isRequired: options.isRequired,
                options: options_base_1.extractOptionBase(options),
                key: _propKey.toString(),
                name: (_b = options.name) !== null && _b !== void 0 ? _b : _propKey.toString(),
                deserializer: options.deserializer,
                serializer: options.serializer,
            });
        };
    }
}
exports.jsonMember = jsonMember;
function isSpecialPropertyType(decoratorName, typeDescriptor) {
    if (!(typeDescriptor instanceof type_descriptor_1.ArrayTypeDescriptor) && typeDescriptor.ctor === Array) {
        helpers_1.logError(decoratorName + ": property is an Array. Use the jsonArrayMember decorator to"
            + " serialize this property.");
        return true;
    }
    if (!(typeDescriptor instanceof type_descriptor_1.SetTypeDescriptor) && typeDescriptor.ctor === Set) {
        helpers_1.logError(decoratorName + ": property is a Set. Use the jsonSetMember decorator to"
            + " serialize this property.");
        return true;
    }
    if (!(typeDescriptor instanceof type_descriptor_1.MapTypeDescriptor) && typeDescriptor.ctor === Map) {
        helpers_1.logError(decoratorName + ": property is a Map. Use the jsonMapMember decorator to"
            + " serialize this property.");
        return true;
    }
    return false;
}
//# sourceMappingURL=json-member.js.map