"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonMapMember = void 0;
var helpers_1 = require("./helpers");
var metadata_1 = require("./metadata");
var options_base_1 = require("./options-base");
var type_descriptor_1 = require("./type-descriptor");
function jsonMapMember(keyConstructor, valueConstructor, options) {
    if (options === void 0) { options = {}; }
    return function (target, propKey) {
        var _a;
        var decoratorName = "@jsonMapMember on " + helpers_1.nameof(target.constructor) + "." + String(propKey);
        if (!type_descriptor_1.isTypelike(keyConstructor)) {
            helpers_1.logError(decoratorName + ": could not resolve constructor of map keys at runtime.");
            return;
        }
        if (!type_descriptor_1.isTypelike(valueConstructor)) {
            helpers_1.logError(decoratorName + ": could not resolve constructor of map values at runtime.");
            return;
        }
        if (helpers_1.isReflectMetadataSupported
            && Reflect.getMetadata('design:type', target, propKey) !== Map) {
            helpers_1.logError(decoratorName + ": property is not a Map. " + helpers_1.MISSING_REFLECT_CONF_MSG);
            return;
        }
        metadata_1.injectMetadataInformation(target, propKey, {
            type: type_descriptor_1.MapT(keyConstructor, valueConstructor, { shape: options.shape }),
            emitDefaultValue: options.emitDefaultValue,
            isRequired: options.isRequired,
            options: options_base_1.extractOptionBase(options),
            key: propKey.toString(),
            name: (_a = options.name) !== null && _a !== void 0 ? _a : propKey.toString(),
            deserializer: options.deserializer,
            serializer: options.serializer,
        });
    };
}
exports.jsonMapMember = jsonMapMember;
//# sourceMappingURL=json-map-member.js.map